<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Endless Top-Down Shooter</title>
  <style>
    body { margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; background: #111; }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

let gameState = 'playing';
let wave = 1;
let enemies = [];
let bullets = [];
let upgradeChoices = [];

const player = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  size: 20,
  speed: 4,
  damage: 1,
  fireRate: 300,
  lastShot: 0,
  bulletSpeed: 7,
  piercing: 0,
  forceField: 0,
  shotgun: 0,
  explosive: 0
};

const upgradePool = [
  { name: 'Extra Damage', desc: '+1 Damage', icon: '💥', apply: () => player.damage++ },
  { name: 'Fire Rate', desc: 'Shoot faster', icon: '⚡', apply: () => player.fireRate = Math.max(50, player.fireRate - 50) },
  { name: 'Bullet Speed', desc: 'Faster bullets', icon: '🚀', apply: () => player.bulletSpeed += 2 },
  { name: 'Move Speed', desc: 'Run faster', icon: '🏃', apply: () => player.speed += 0.5 },
  { name: 'Piercing', desc: 'Bullets pierce enemies', icon: '🎯', apply: () => player.piercing++ },
  { name: 'Force Field', desc: 'Pushes enemies away', icon: '🛡️', apply: () => player.forceField++ },
  { name: 'Shotgun', desc: 'Fires more bullets in spread', icon: '🔫', apply: () => player.shotgun++ },
  { name: 'Explosive', desc: 'Bullets explode on hit', icon: '💣', apply: () => player.explosive++ }
];

function spawnWave() {
  const enemyCount = Math.max(3, wave * 3); // Fewer enemies at start
  for (let i = 0; i < enemyCount; i++) {
    enemies.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: 20,
      hp: Math.random() < 0.3 ? 5 : 2, // Red enemies have 5 HP, others 2
      red: Math.random() < 0.3
    });
  }
}

function update() {
  if (gameState === 'playing') {
    if (keys['w']) player.y -= player.speed;
    if (keys['s']) player.y += player.speed;
    if (keys['a']) player.x -= player.speed;
    if (keys['d']) player.x += player.speed;

    if (keys['arrowup']) shoot(0, -1);
    if (keys['arrowdown']) shoot(0, 1);
    if (keys['arrowleft']) shoot(-1, 0);
    if (keys['arrowright']) shoot(1, 0);

    enemies.forEach(e => {
      const dx = player.x - e.x;
      const dy = player.y - e.y;
      const dist = Math.hypot(dx, dy);
      e.x += dx / dist;
      e.y += dy / dist;
      if (player.forceField > 0 && dist < player.size + e.size) {
        e.x -= dx / dist * (5 + player.forceField * 3);
        e.y -= dy / dist * (5 + player.forceField * 3);
      }
    });

    bullets.forEach(b => {
      b.x += b.vx;
      b.y += b.vy;
    });

    bullets = bullets.filter(b => b.x > 0 && b.x < canvas.width && b.y > 0 && b.y < canvas.height);
    enemies = enemies.filter(e => e.hp > 0);

    bullets.forEach(b => {
      enemies.forEach(e => {
        if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) {
          let dmg = player.damage;
          if (player.shotgun > 0) dmg *= 0.8;
          if (player.explosive > 0) dmg *= 0.8;
          e.hp -= dmg;
          if (player.explosive > 0) {
            enemies.forEach(ee => {
              if (Math.hypot(b.x - ee.x, b.y - ee.y) < 50 + player.explosive * 10) ee.hp -= dmg;
            });
          }
          if (player.piercing <= 0) b.dead = true;
        }
      });
    });

    bullets = bullets.filter(b => !b.dead);

    if (enemies.length === 0) {
      gameState = 'upgrade';
      upgradeChoices = [];
      let pool = [...upgradePool];
      for (let i = 0; i < 3; i++) {
        const idx = Math.floor(Math.random() * pool.length);
        upgradeChoices.push(pool.splice(idx, 1)[0]);
      }
    }
  }
}

function shoot(dx, dy) {
  const now = Date.now();
  if (now - player.lastShot > player.fireRate) {
    player.lastShot = now;
    if (player.shotgun > 0) {
      let spreadCount = 3 + (player.shotgun - 1) * 3;
      for (let i = 0; i < spreadCount; i++) {
        const spreadAngle = (i - (spreadCount - 1) / 2) * 0.15;
        const angle = Math.atan2(dy, dx) + spreadAngle;
        bullets.push({
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * player.bulletSpeed,
          vy: Math.sin(angle) * player.bulletSpeed
        });
      }
    } else {
      bullets.push({ x: player.x, y: player.y, vx: dx * player.bulletSpeed, vy: dy * player.bulletSpeed });
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (gameState === 'playing') {
    ctx.fillStyle = 'cyan';
    ctx.fillRect(player.x - player.size / 2, player.y - player.size / 2, player.size, player.size);

    enemies.forEach(e => {
      ctx.fillStyle = e.red ? 'red' : 'green';
      ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
    });

    ctx.fillStyle = 'yellow';
    bullets.forEach(b => ctx.fillRect(b.x - 5, b.y - 5, 10, 10));

    ctx.fillStyle = 'white';
    ctx.fillText(`Wave: ${wave}`, 20, 20);
  } else if (gameState === 'upgrade') {
    ctx.fillStyle = 'white';
    ctx.font = '30px Arial';
    ctx.fillText('Choose an upgrade', canvas.width / 2 - 150, 100);

    upgradeChoices.forEach((u, i) => {
      const boxWidth = 180;
      const boxHeight = 150;
      const boxX = canvas.width / 4 * (i + 1) - boxWidth / 2;
      const boxY = canvas.height / 2 - boxHeight / 2;

      ctx.fillStyle = '#222';
      ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

      ctx.strokeStyle = '#fff';
      ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

      ctx.font = '40px Arial';
      ctx.fillText(u.icon, boxX + boxWidth / 2 - 20, boxY + 50);

      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.fillText(u.name, boxX + 10, boxY + 90);
      ctx.font = '16px Arial';
      ctx.fillText(u.desc, boxX + 10, boxY + 120);
    });
  }
}

canvas.addEventListener('click', e => {
  if (gameState === 'upgrade') {
    upgradeChoices.forEach((u, i) => {
      const boxWidth = 180;
      const boxHeight = 150;
      const boxX = canvas.width / 4 * (i + 1) - boxWidth / 2;
      const boxY = canvas.height / 2 - boxHeight / 2;
      if (e.clientX >= boxX && e.clientX <= boxX + boxWidth && e.clientY >= boxY && e.clientY <= boxY + boxHeight) {
        u.apply();
        wave++;
        spawnWave();
        gameState = 'playing';
      }
    });
  }
});

spawnWave();
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>


